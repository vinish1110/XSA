const { getNavigationIfStruct } = require('./structured')
const getColumns = require('../../db/utils/columns')
const { ensureDraftsSuffix, ensureNoDraftsSuffix } = require('./draft')
const { getEntityNameFromCQN } = require('./entityFromCqn')

const isAsteriskColumn = col => col === '*' || (col.ref && col.ref[0] === '*' && !col.expand)

const _isDuplicate = newColumn => column => {
  if (newColumn.as) return column.as && column.as === newColumn.as
  if (!column.ref) return
  if (Array.isArray(newColumn)) newColumn = { ref: newColumn }
  return newColumn.ref ? newColumn.ref.join('_') === column.ref.join('_') : newColumn === column.ref.join('_')
}

const _cqlDraftColumns = target => {
  if (target.name.endsWith('DraftAdministrativeData')) return []
  const draftName = ensureDraftsSuffix(target.name)
  const subSelect = SELECT.from(draftName).columns([1])
  for (const key in target.keys) {
    if (key !== 'IsActiveEntity') subSelect.where([{ ref: [target.name, key] }, '=', { ref: [draftName, key] }])
  }
  return [
    { val: true, as: 'IsActiveEntity', cast: { type: 'cds.Boolean' } },
    { val: false, as: 'HasActiveEntity', cast: { type: 'cds.Boolean' } },
    {
      xpr: ['case', 'when', 'exists', subSelect, 'then', 'true', 'else', 'false', 'end'],
      as: 'HasDraftEntity',
      cast: { type: 'cds.Boolean' }
    }
  ]
}

const _expandColumn = (column, target, db) => {
  if (!(column.ref && column.expand)) return
  const nextTarget = getNavigationIfStruct(target, column.ref)
  if (nextTarget && nextTarget._target && nextTarget._target.elements) _rewriteAsterisks(column, nextTarget._target, db)
  return column
}

const rewriteExpandAsterisk = (columns, target) => {
  const expandAllColIdx = columns.findIndex(col => {
    if (col.ref || !col.expand) return
    return !Array.isArray(col.expand) ? col.expand === '*' : col.expand.indexOf('*') > -1
  })
  if (expandAllColIdx > -1) {
    const { expand } = columns.splice(expandAllColIdx, 1)[0]
    for (const elName in target.elements) {
      if (target.elements[elName]._target && !columns.find(col => col.expand && col.ref && col.ref[0] === elName)) {
        columns.push({ ref: [elName], expand: [...expand] })
      }
    }
  }
}

const _rewriteAsterisk = (columns, target, db, isRoot) => {
  const asteriskColumnIndex = columns.findIndex(col => isAsteriskColumn(col))
  if (asteriskColumnIndex > -1) {
    columns.splice(
      asteriskColumnIndex,
      1,
      ...getColumns(target, { db })
        .map(c => ({ ref: [c.name] }))
        .filter(c => !columns.find(_isDuplicate(c)) && (isRoot || c.ref[0] !== 'DraftAdministrativeData_DraftUUID'))
    )
  }
}

const _rewriteAsterisks = (cqn, target, db, isRoot) => {
  if (cqn.expand === '*') cqn.expand = ['*']
  const columns = cqn.expand || cqn.columns
  _rewriteAsterisk(columns, target, db, isRoot)
  rewriteExpandAsterisk(columns, target)
  for (const column of columns) {
    _expandColumn(column, target, db)
  }
  return columns
}

const _targetOfQueryIfNotDraft = (query, model) => {
  const { entityName } = getEntityNameFromCQN(query)
  const target = model.definitions[entityName]
  if (!target || target.name.endsWith('_drafts')) return
  return target
}

const rewriteAsterisks = (query, model, db = false, isDraft = false, onlyKeys = false) => {
  if (!query.SELECT.columns || !query.SELECT.columns.length) {
    if (isDraft || db) {
      if (
        query.SELECT.from.SET &&
        query.SELECT.from.SET.args[0] &&
        query.SELECT.from.SET.args[0].SELECT &&
        query.SELECT.from.SET.args[0].SELECT.columns
      ) {
        // > best-effort derive column list from first join element if given
        query.SELECT.columns = query.SELECT.from.SET.args[0].SELECT.columns.map(c => ({
          ref: [c.as || c.ref[c.ref.length - 1]]
        }))
      } else if (query.SELECT.from.join && query.SELECT.from.args) {
        if (!query.SELECT.columns) query.SELECT.columns = []
        for (const arg of query.SELECT.from.args) {
          const _targetName = arg.ref[0].id || arg.ref[0]
          const _target = model.definitions[ensureNoDraftsSuffix(_targetName)]
          const columns = getColumns(_target, { db, onlyKeys })
            .filter(
              c =>
                !query.SELECT.columns.some(
                  existing => (existing.as || existing.ref[existing.ref.length - 1]) === c.name
                )
            )
            .map(col => ({
              ref: [arg.as || _targetName, col.name]
            }))
          columns.forEach(c => query.SELECT.columns.push(c))
        }
      } else {
        const target = _targetOfQueryIfNotDraft(query, model)
        if (!target) return
        query.SELECT.columns = getColumns(target, { db, onlyKeys }).map(col => ({ ref: [col.name] }))
        if (db && target._isDraftEnabled) query.SELECT.columns.push(..._cqlDraftColumns(target))
      }
    }
    return
  }
  const target = _targetOfQueryIfNotDraft(query, model)
  if (!target) return
  // REVISIT: Also support JOINs/SETs here
  query.SELECT.columns = _rewriteAsterisks(query.SELECT, target, db, true)
}

module.exports = {
  rewriteAsterisks,
  isAsteriskColumn,
  rewriteExpandAsterisk
}
