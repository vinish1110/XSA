const cds = require('../../cds')

const { ensureNoDraftsSuffix } = require('./draft')

const getEtagElement = entity => {
  return Object.values(entity.elements).find(element => element['@odata.etag'])
}

const _getUps = (entity, model) => {
  const ups = []
  for (const def of Object.values(model.definitions)) {
    if (def.kind !== 'entity' || !def.associations) continue
    for (const element of Object.values(def.associations)) {
      if (element.target !== entity.name || element._isBacklink) continue
      if (element.name === 'SiblingEntity') continue
      ups.push(element)
    }
  }
  return ups
}

const _ifDataSubject = (entity, role) => {
  return entity['@PersonalData.EntitySemantics'] === 'DataSubject' && entity['@PersonalData.DataSubjectRole'] === role
}

const _getDataSubjectUp = (role, model, entity, prev, next, result) => {
  for (const element of _getUps(entity, model)) {
    const me = { entity, relative: element.parent, element }
    if (prev) prev.next = me
    if (_ifDataSubject(element.parent, role)) {
      if (!result) result = { dataSubjectEntity: element.parent, subs: [] }
      result.subs.push(next || me)
      return result
    } else {
      // dfs is a must here
      result = _getDataSubjectUp(role, model, element.parent, me, next || me, result)
    }
  }
  return result
}

const _getDataSubjectDown = (role, entity, prev, next) => {
  const associations = Object.values(entity.associations).filter(e => !e._isBacklink)
  for (const element of associations) {
    const me = { entity, relative: entity, element }
    if (_ifDataSubject(element._target, role)) {
      if (prev) prev.next = me
      return { dataSubjectEntity: element._target, subs: [next || me] }
    }
  }
  // bfs makes more sense here
  for (const element of associations) {
    const me = { entity, relative: entity, element }
    if (prev) prev.next = me
    const dataSubject = _getDataSubjectDown(role, element._target, me, next || me)
    if (dataSubject) return dataSubject
  }
}

const getDataSubject = (entity, model, role) => {
  const hash = '__dataSubject4' + role
  if (entity.own(hash)) return entity[hash]
  // entities with EntitySemantics 'DataSubjectDetails' or 'Other' must not necessarily
  // be always below or always above 'DataSubject' entity in CSN tree
  let dataSubject = _getDataSubjectUp(role, model, entity)
  if (!dataSubject) {
    dataSubject = _getDataSubjectDown(role, entity)
  }
  return entity.set(hash, dataSubject)
}

const _resolve = (name, model, namespace) =>
  model.entities(namespace)[name] || model.definitions[`${namespace}.${name}`]

const _findRootEntity = (model, edmName, namespace) => {
  const parts = edmName.split('_')
  let csnName = parts.shift()
  let target = _resolve(csnName, model, namespace)
  const len = parts.length
  // try to find a correct entity "greedy" and count leftovers (x4 case below)
  // e.g. we have 2 entities: 'C_root_' and dependant 'C_root_.kid_'
  // for 'C_root_.kid_assoc_prop' it should find 'C_root_.kid_'
  // and report 2 leftovers (namely 'assoc' and 'prop')
  let left = len
  let acc = 0
  for (let i = 0; i < len; i++) {
    /**
     * Calculate CSN name.
     * if target in entities connect with .
     * if target not in entities connect with _
     */
    csnName = `${csnName}${_resolve(csnName, model, namespace) ? '.' : '_'}${parts[i]}`
    ++acc
    if (_resolve(csnName, model, namespace)) {
      target = _resolve(csnName, model, namespace)
      left -= acc
      acc = 0
    }
  }
  // make sure we consider leftovers only for x4
  return { left: (cds.env.effective.odata.proxies && left) || 0, target: target }
}

const findCsnTargetFor = (edmName, model, namespace) => {
  const cache =
    model._edmToCSNNameMap || Object.defineProperty(model, '_edmToCSNNameMap', { value: {} })._edmToCSNNameMap
  const mapping =
    cache[namespace] ||
    Object.defineProperty(cache, namespace, { enumerable: true, configurable: true, value: {} })[namespace]

  if (mapping[edmName]) return mapping[edmName]

  // simple cases
  let target = _resolve(edmName, model, namespace) || _resolve(edmName.replace(/_/g, '.'), model, namespace)

  // hard cases
  if (!target) {
    // probably, a combination of '_' and '.', resolving
    const finding = _findRootEntity(model, edmName, namespace)
    target = finding.target
    // something left in navigation path => x4 navigation
    // resolving within found entity
    if (target && finding.left > 0) {
      const left = edmName.split('_').slice(-finding.left)
      while (target && left.length) {
        let elm = left.shift()
        while (!target.elements[elm]) elm = `${elm}_${left.shift()}`
        target = target.elements[elm]
      }
    }
  }
  // remember edm <-> csn
  if (target) {
    mapping[edmName] = target
  }
  return mapping[edmName]
}

const getElementDeep = (entity, ref) => {
  let current = entity
  for (const r of ref) {
    current = current && current.elements && current.elements[r]
  }
  return current
}

const isRootEntity = (definitions, entityName) => {
  const entity = definitions[entityName]
  if (!entity) return false

  // TODO: There can be unmanaged relations to some parent -> not detected by the following code
  const associationElements = Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(element => element._isAssociationEffective)

  for (const { target } of associationElements) {
    const parentEntity = definitions[target]
    for (const parentElementName in parentEntity.elements) {
      const parentElement = parentEntity.elements[parentElementName]
      if (
        parentElement._isCompositionEffective &&
        parentElement.target === entityName &&
        !(parentElement.parent && ensureNoDraftsSuffix(parentElement.parent.name) === entityName)
      ) {
        return false
      }
    }
  }
  return true
}

function alias2ref(service, edm) {
  const defs = edm[service.definition.name]
  for (const each of Object.values(service.entities)) {
    const def = defs[each.name.replace(service.definition.name + '.', '').replace(/\./g, '_')]
    if (!def || !def.$Key || def.$Key.every(ele => typeof ele === 'string')) continue
    each._alias2ref = {}
    for (const mapping of def.$Key.filter(ele => typeof ele !== 'string')) {
      for (const [key, value] of Object.entries(mapping)) {
        each._alias2ref[key] = value.split('/')
      }
    }
  }
}

module.exports = {
  getEtagElement,
  findCsnTargetFor,
  getElementDeep,
  isRootEntity,
  getDataSubject,
  alias2ref
}
