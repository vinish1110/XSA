const cds = require('../../../../cds')
const LOG = cds.log('odata')

const { SELECT } = cds.ql

const { targetFromPath, isPathToDraft } = require('../../../../common/utils/cqn')
const { deepCopyArray } = require('../../../../common/utils/copy')

const isStreaming = segments => {
  const lastSegment = segments[segments.length - 1]
  return (
    segments.length > 1 &&
    lastSegment.getKind() === 'PRIMITIVE.PROPERTY' &&
    lastSegment.getProperty().getType().getName() === 'Stream'
  )
}

const getStreamProperties = (req, model) => {
  const mediaTypeProperty = Object.values(req.target.elements).find(val => val['@Core.MediaType'])

  let contentType, contentDisposition
  const columns = []
  if (typeof mediaTypeProperty['@Core.MediaType'] === 'object') {
    let contentTypeProperty = mediaTypeProperty['@Core.MediaType']['=']
    if (!req.target.elements[contentTypeProperty]) {
      LOG._warn &&
        LOG.warn(
          `@Core.MediaType in entity "${req.target.name}" points to property "${contentTypeProperty}" which was renamed or is not part of the projection. You must update the annotation value.`
        )
      contentTypeProperty = (Object.values(req.target.elements).find(val => val['@Core.IsMediaType']) || {}).name
    }
    if (!req.target.elements[contentTypeProperty]) {
      LOG._warn && LOG.warn(`No @Core.IsMediaType found in entity "${req.target.name}".`)
    } else {
      columns.push({ ref: [contentTypeProperty], as: 'contentType' })
    }
  } else {
    contentType = mediaTypeProperty['@Core.MediaType']
  }
  if (mediaTypeProperty['@Core.ContentDisposition.Filename']) {
    if (typeof mediaTypeProperty['@Core.ContentDisposition.Filename'] === 'object') {
      const contentDispositionProperty = mediaTypeProperty['@Core.ContentDisposition.Filename']['=']
      if (!req.target.elements[contentDispositionProperty]) {
        LOG._warn &&
          LOG.warn(
            `@Core.ContentDisposition.Filename in entity "${req.target.name}" points to property "${contentDispositionProperty}" which was renamed or is not part of the projection. You must update the annotation value.`
          )
      } else {
        columns.push({ ref: [contentDispositionProperty], as: 'contentDisposition' })
      }
    } else {
      contentDisposition = mediaTypeProperty['@Core.ContentDisposition.Filename']
    }
  }

  if (columns.length && cds.db && !req.target._hasPersistenceSkip) {
    // used cloned path
    const select = SELECT.one.from({ ref: deepCopyArray(req.query.SELECT.from.ref) }).columns(columns)

    if (req.target._isDraftEnabled && isPathToDraft(select.SELECT.from.ref, model))
      select.SELECT.from.ref[0].id = select.SELECT.from.ref[0].id + '_drafts'

    // new parser has media property as last ref element -> remove
    if (targetFromPath(select.SELECT.from.ref, model).kind === 'element') select.SELECT.from.ref.pop()

    return cds
      .tx(req)
      .run(select)
      .then(res => ({
        contentType: (res && res.contentType) || contentType,
        contentDisposition: (res && res.contentDisposition) || contentDisposition
      }))
  }

  return Promise.resolve({ contentType, contentDisposition })
}

module.exports = {
  isStreaming,
  getStreamProperties
}
