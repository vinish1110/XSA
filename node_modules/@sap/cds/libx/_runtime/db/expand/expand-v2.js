const cds = require('../../cds')
const getColumns = require('../utils/columns')

const _identifierForRow = (row, prefix, keys) => {
  return keys.map(k => row[`${prefix}${k}`]).join(',')
}

const _removeParentKeysFromRow = (row, prefix, keys) => {
  for (const k of keys) {
    delete row[`${prefix}${k}`]
  }
}

const _autoExpandNavsAndAttachToResult = async (entity, previousResult, depth) => {
  for (const nav in entity._associations) {
    const navigation = entity._associations[nav]

    // do not expand backlinks
    if (navigation._isBacklink) continue

    const childAlias = 'child'
    const parentAlias = 'parent'

    const cqnQuery = SELECT.from(`${navigation.target} as ${childAlias}`)
      .join(`${entity.name} as ${parentAlias}`)
      .on(entity._relations[navigation.name].join(childAlias, parentAlias))

    // set alias for expanded columns already
    const childColumns = getColumns(navigation._target).map(c => ({ ref: [childAlias, c.name] }))
    const parentKeys = Object.keys(entity.keys).filter(k => !entity.keys[k].isAssociation)
    // mark parent key with prefix in alias
    const parentKeysWithAlias = parentKeys.map(pk => ({ ref: [parentAlias, pk], as: `$$pk_${pk}` }))
    cqnQuery.columns(...childColumns, ...parentKeysWithAlias)

    // add tuple comparison for where clause
    cqnQuery.where([
      { list: parentKeys.map(pk => ({ ref: [parentAlias, pk] })) },
      'in',
      { list: previousResult.map(row => ({ list: parentKeys.map(pk => ({ val: row[pk] })) })) }
    ])

    // sort by primary keys of parent, required in future
    cqnQuery.orderBy(parentKeys.map(pk => ({ ref: [parentAlias, pk] })))

    const result = await cds.db.run(cqnQuery)

    // TODO: Is there a more efficient/stable way to handle compound keys?
    const map = new Map()
    for (const row of result) {
      const identifier = _identifierForRow(row, '$$pk_', parentKeys)
      _removeParentKeysFromRow(row, '$$pk_', parentKeys)
      if (map.has(identifier)) {
        map.get(identifier).push(row)
      } else {
        map.set(identifier, [row])
      }
    }

    // link previous result with current result
    previousResult.forEach(row => {
      const identifier = _identifierForRow(row, '', parentKeys)
      if (map.has(identifier)) {
        const entry = map.get(identifier)
        row[nav] = navigation.is2one ? entry[0] : entry
      } else {
        row[nav] = navigation.is2one ? null : []
      }
    })

    // expand next level if needed
    if (depth - 1 !== 0 && result.length && navigation._target._associations) {
      await _autoExpandNavsAndAttachToResult(navigation._target, result, depth - 1)
    }
  }

  return previousResult
}

const _foreignKeysOfTopLevelNavs = entity => {
  const requiredFks = new Set()
  for (const nav in entity._associations) {
    const onCond = entity._relations[nav].join('child', 'parent')
    for (const ele of onCond) {
      if (ele.ref && ele.ref[0] === 'parent') {
        requiredFks.add(ele.ref.slice(1).join('_'))
      }
    }
  }
  return [...requiredFks]
}

/**
 * 1. Creates flattened SQL statements for each expand layer
 * 2. Mixes in foreign keys if needed
 * 3. Merges results
 * 4. Cleans result if needed
 *
 * @returns object
 */
const expandV2 = async (model, dbc, query, user, locale, txTimestamp, executeSelectCQN) => {
  // remove expand columns from query without modifying
  const topLevelSelect = query.clone().columns(query.SELECT.columns.filter(c => !c.expand))

  const entity = model.definitions[topLevelSelect.SELECT.from.ref[0]]

  // ensure foreign keys are selected if needed
  const fks = _foreignKeysOfTopLevelNavs(entity)
  fks.forEach(fk => {
    if (!topLevelSelect.SELECT.columns.some(c => c.ref[0] === fk)) {
      topLevelSelect.SELECT.columns.push({ ref: [fk] })
    }
  })

  const result = await executeSelectCQN(model, dbc, topLevelSelect, user, locale, txTimestamp)

  if (!result || (Array.isArray(result) && !result.length)) {
    return result
  }

  // _associations contains compositions and associations
  if (entity._associations) {
    const expandColumn = query.SELECT.columns.find(c => c.expand && typeof c.expand === 'string')
    const depth = expandColumn.expand === '**' ? -1 : Number(expandColumn.expand.replace('*', ''))
    await _autoExpandNavsAndAttachToResult(entity, Array.isArray(result) ? result : [result], depth)
  }

  return result
}

module.exports = expandV2
