const cds = require('../../cds.js')
const LOG = cds.log('messaging')
const ClientAmqp = require('@sap/xb-msg-amqp-v100').Client
const { connect, disconnect } = require('./connections')
const { hasPersistentOutbox } = require('../outbox/utils')

const _JSONorString = string => {
  try {
    return JSON.parse(string)
  } catch (e) {
    return string
  }
}

const addDataListener = (client, queue, prefix, cb) =>
  new Promise((resolve, reject) => {
    const source = `${prefix}${queue}`
    client
      .receiver(queue)
      .attach(source)
      .on('data', async raw => {
        const buffer = raw.payload && Buffer.concat(raw.payload.chunks)
        const payload = buffer && _JSONorString(buffer.toString())
        const topic =
          raw.source &&
          raw.source.properties &&
          raw.source.properties.to &&
          raw.source.properties.to.replace(/^topic:\/*/, '')
        if (!topic) return raw.done()
        await cb(topic, payload, null, { done: raw.done, failed: raw.failed })
      })
      .on('subscribed', () => {
        resolve()
      })
  })

const sender = (client, optionsApp) => client.sender(`${optionsApp.appName}-${optionsApp.appID}`)

const emit = ({ data, event: topic, headers = {} }, stream, prefix) =>
  new Promise((resolve, reject) => {
    LOG._info && LOG.info('Emit', { topic })
    const message = { ...headers, data }
    const payload = { chunks: [Buffer.from(JSON.stringify(message))], type: 'application/json' }
    const msg = {
      done: resolve,
      failed: e => {
        if (e.condition === 'amqp:not-allowed') e.unrecoverable = true
        reject(e)
      },
      payload,
      target: {
        properties: {
          to: `${prefix}${topic}`
        }
      }
    }
    stream.write(msg)
  })

class AMQPClient {
  constructor({ optionsAMQP, prefix, service, keepAlive = true }) {
    this.optionsAMQP = optionsAMQP
    this.prefix = prefix
    this.keepAlive = keepAlive
    this.service = service
  }

  connect() {
    this.client = new ClientAmqp(this.optionsAMQP)
    this.sender = sender(this.client, this.service.optionsApp)
    this.stream = this.sender.attach('')
    return connect(this.client, this.keepAlive)
  }

  async disconnect() {
    if (this.client) {
      await disconnect(this.client)
      delete this.client
    }
  }

  async emit(msg) {
    if (!this.client) await this.connect()
    // REVISIT: Is this a robust way to find out if the connection is working?
    if (hasPersistentOutbox(this.service, cds.context && cds.context.tenant) && !this.sender.opened())
      throw new Error('AMQP: Sender is not open')
    await emit(msg, this.stream, this.prefix.topic)
    if (!this.keepAlive) return this.disconnect()
  }

  listen(cb) {
    return addDataListener(this.client, this.service.queueName, this.prefix.queue, cb)
  }
}

module.exports = AMQPClient
