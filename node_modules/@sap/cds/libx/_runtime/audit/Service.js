const cds = require('../cds')
const OutboxService = require('../messaging/Outbox')

const v2utils = require('./utils/v2')

const ANONYMOUS = 'anonymous'

const _getTenantAndUser = () => ({
  user: (cds.context && cds.context.user && cds.context.user.id) || ANONYMOUS,
  tenant: (cds.context && cds.context.tenant) || ANONYMOUS
})

module.exports = class AuditLogService extends OutboxService {
  async init() {
    // call OutboxService's init, which handles outboxing
    await super.init()

    // register handlers
    this.on('dataAccessLog', this.dataAccessLog)
    this.on('dataModificationLog', this.dataModificationLog)
    this.on('securityLog', this.securityLog)
    this.on('configChangeLog', this.configChangeLog)

    // connect to audit log service
    // REVISIT for GA: throw error on connect issue instead of warn and this.ready?
    this.alc = await v2utils.connect(this.options.credentials)
    this.ready = !!this.alc
  }

  async emit(first, second) {
    const { event, data } = typeof first === 'object' ? first : { event: first, data: second }
    if (!this.options.outbox) return this.send(event, data)

    if (this.ready && this[event]) {
      try {
        // this will open a new tx -> preserve user
        await super.send(new cds.Request({ method: event, data, user: cds.context.user }))
      } catch (e) {
        if (e.code === 'ERR_ASSERTION') {
          e.unrecoverable = true
        }
        throw e
      }
    }
  }

  async send(event, data) {
    if (this.ready && this[event]) return super.send(event, data)
  }

  async dataAccessLog(arg) {
    const accesses = arg.accesses || arg.data.accesses

    if (!this.ready) throw new Error('AuditLogService not connected')

    const { tenant, user } = _getTenantAndUser()

    // build the logs
    const { entries, errors } = v2utils.buildDataAccessLogs(this.alc, accesses, tenant, user)
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }

    // write the logs
    await Promise.all(
      entries.map(entry => {
        v2utils.sendDataAccessLog(entry).catch(err => errors.push(err))
      })
    )
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }
  }

  // REVISIT: modification.action not used in auditlog v2
  async dataModificationLog(arg) {
    const modifications = arg.modifications || arg.data.modifications

    if (!this.ready) throw new Error('AuditLogService not connected')

    const { tenant, user } = _getTenantAndUser()

    // build the logs
    const { entries, errors } = v2utils.buildDataModificationLogs(this.alc, modifications, tenant, user)
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }

    // write the logs
    await Promise.all(
      entries.map(entry => {
        v2utils.sendDataModificationLog(entry).catch(err => errors.push(err))
      })
    )
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }
  }

  async securityLog(arg) {
    let { action, data } = arg
    if (arg.data && arg.data.action) {
      action = arg.data.action
      data = arg.data.data
    }

    if (!this.ready) throw new Error('AuditLogService not connected')

    let { tenant, user } = _getTenantAndUser()

    // cds.context may not be proper on auth-related errors -> try to extract from data
    if (tenant === ANONYMOUS && user === ANONYMOUS) {
      try {
        const parsed = JSON.parse(data)
        if (parsed.tenant) {
          tenant = parsed.tenant
          delete parsed.tenant
        }
        if (parsed.user && typeof parsed.user === 'string') {
          user = parsed.user
          delete parsed.user
        }
        data = JSON.stringify(parsed)
      } catch (e) {}
    }

    // build the log
    const entry = v2utils.buildSecurityLog(this.alc, action, data, tenant, user)

    // write the log
    await v2utils.sendSecurityLog(entry)
  }

  // REVISIT: action and success not used in auditlog v2
  async configChangeLog(arg) {
    let { action, success, configurations } = arg
    if (arg.data) {
      // eslint-disable-next-line no-unused-vars
      action = arg.data.action
      // eslint-disable-next-line no-unused-vars
      success = arg.data.success
      configurations = arg.data.configurations
    }

    if (!this.ready) throw new Error('AuditLogService not connected')

    const { tenant, user } = _getTenantAndUser()

    // build the logs
    const { entries, errors } = v2utils.buildConfigChangeLogs(this.alc, configurations, tenant, user)
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }

    // write the logs
    await Promise.all(
      entries.map(entry => {
        v2utils.sendConfigChangeLog(entry).catch(err => errors.push(err))
      })
    )
    if (errors.length) {
      throw errors.length === 1 ? errors[0] : Object.assign(new Error('MULTIPLE_ERRORS'), { details: errors })
    }
  }
}
