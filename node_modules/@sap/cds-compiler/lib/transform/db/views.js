'use strict';

const { usesMixinAssociation, getMixinAssocOfQueryIfPublished } = require('./helpers');
const { getUtils, cloneCsn } = require('../../model/csnUtils');
const { implicitAs, csnRefs } = require('../../model/csnRefs');
const { isBetaEnabled } = require('../../base/model');


/**
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 * @param {{error: Function, info: Function}} messageFunctions
 * @param {Function} transformCommon For the time being: Pass from outside
 * @returns {(query: CSN.Query, artifact: CSN.Artifact, artName: string, path: CSN.Path) => void} Transformer function for views
 */
function getViewTransformer(csn, options, messageFunctions, transformCommon) {
  const {
    get$combined, cloneWithTransformations, isAssocOrComposition,
  } = getUtils(csn);
  const { inspectRef, queryOrMain } = csnRefs(csn);
  const pathDelimiter = (options.forHana.names === 'hdbcds') ? '.' : '_';
  const { error, info } = messageFunctions;
  const doA2J = !(options.transformation === 'hdbcds' && options.sqlMapping === 'hdbcds');

  return transformViewOrEntity;

  /**
   *
   * check all queries/subqueries for mixin publishing inside of unions -> forbidden in hdbcds
   *
   * @param {CSN.Query} query
   * @param {CSN.Elements} elements
   * @param {CSN.Path} path
   */
  function checkForMixinPublishing(query, elements, path) {
    for (const elementName in elements) {
      const element = elements[elementName];
      if (element.target) {
        let colLocation;
        for (let i = 0; i < query.SELECT.columns.length; i++) {
          const col = query.SELECT.columns[i];
          if (col.ref && col.ref.length === 1) {
            if (!colLocation && col.ref[0] === elementName)
              colLocation = i;


            if (col.as === elementName)
              colLocation = i;
          }
        }
        if (colLocation) {
          const matchingCol = query.SELECT.columns[colLocation];
          const possibleMixinName = matchingCol.ref[0];
          const isMixin = query.SELECT.mixin[possibleMixinName] !== undefined;
          if (element.target && isMixin) {
            error(null, path.concat([ 'columns', colLocation ]), { id: elementName, name: possibleMixinName, '#': possibleMixinName === elementName ? 'std' : 'renamed' }, {
              std: 'Element $(ID) is a mixin association and can\'t be published in a UNION',
              renamed: 'Element $(ID) is a mixin association ($(NAME))and can\'t be published in a UNION',
            });
          }
        }
      }
    }
  }
  /**
   * Build a map of the resulting names (i.e. the element name of the column) and references to the respective columns
   *
   * This can later be used to match from elements to columns.
   *
   * @param {CSN.Query} query
   * @returns {object}
   */
  function getColumnMap(query) {
    const map = Object.create(null);
    if (query && query.SELECT && query.SELECT.columns) {
      query.SELECT.columns.forEach((col) => {
        if (col === '*') {
          // do nothing
        }
        else if (col.as) {
          if (!map[col.as])
            map[col.as] = col;
        }
        else if (col.ref) {
          // .id on last path step can happen with hdbcds.hdbcds and malicious CSN input - maybe also with params?
          // We made things right in the end with the second add of missing stuff, but why not do it
          // right from the getgo
          const last = getLastRefStepString(col.ref);
          if (!map[last])
            map[last] = col;
        }
        else if (col.func) {
          map[col.func] = col;
        }
        else if (!map[col]) {
          map[col] = col;
        }
      });
    }

    return map;
  }
  /**
   * For things that are not explicitly found in the columns but still present in the elements, add them to the columnMap.
   *
   * This can happen for:
   * - projections, as we might not have .columns at all
   * - *, as we don't resolve it for hdbcds with hdbcds-naming
   *
   * We ensure that we attach a table alias before each column
   *
   * @param {CSN.Query} query
   * @param {boolean} isProjection
   * @param {boolean} isSelectStar
   * @param {object} $combined
   * @param {object} columnMap
   * @param {string} elemName
   */
  function addProjectionOrStarElement(query, isProjection, isSelectStar, $combined, columnMap, elemName) {
    // Prepend an alias if present
    let alias = (isProjection || isSelectStar) &&
    (query.SELECT.from.as || (query.SELECT.from.ref && implicitAs(query.SELECT.from.ref)));
    // In case of * and no explicit alias
    // find the source of the col by looking at $combined and prepend it
    if (isSelectStar && !alias && !isProjection) {
      if (!$combined)
        $combined = get$combined(query);


      const matchingCombined = $combined[elemName];
      // Internal errors - this should never happen!
      if (matchingCombined.length > 1) { // should already be caught by compiler
        throw new Error(`Ambiguous name - can't be resolved: ${elemName}. Found in: ${matchingCombined.map(o => o.parent)}`);
      }
      else if (matchingCombined.length === 0) { // no clue how this could happen? Invalid CSN?
        throw new Error(`No matching entry found in UNION of all elements for: ${elemName}`);
      }
      alias = matchingCombined[0].parent;
    }
    if (alias)
      columnMap[elemName] = { ref: [ alias, elemName ] };
    else
      columnMap[elemName] = { ref: [ elemName ] };
  }

  /**
   * So far, we only added foreign keys to elements - we also need to create corresponding columns
   * and respect aliasing etc.
   *
   * @todo Maybe this can be done earlier, during flattening/expansion already?
   * @param {object} columnMap
   * @param {CSN.Element} elem
   * @param {string} elemName
   */
  function addForeignKeysToColumns(columnMap, elem, elemName) {
    const assocCol = columnMap[elemName];
    if (assocCol && assocCol.ref) {
      elem.keys.forEach((foreignKey) => {
        const ref = cloneCsn(assocCol.ref, options);
        ref[ref.length - 1] = [ getLastRefStepString(ref) ].concat(foreignKey.as).join(pathDelimiter);
        const result = {
          ref,
        };
        if (assocCol.as) {
          const columnName = `${assocCol.as}${pathDelimiter}${foreignKey.as}`;
          result.as = columnName;
        }

        if (assocCol.key)
          result.key = true;

        const colName = result.as || getLastRefStepString(ref);
        columnMap[colName] = result;
      });
    }
  }


  /**
   * Check for invalid association publishing (in Union or in Subquery) (for hdbcds) and
   * create the __clone for publishing stuff.
   *
   * @todo Factor out the checks
   * @todo Union, Join, Subqueries? Assoc usage in there? __clone?
   * @param {CSN.Query} query
   * @param {object} elements
   * @param {object} columnMap
   * @param {WeakMap} publishedMixins Map to collect the published mixins
   * @param {CSN.Element} elem
   * @param {string} elemName
   * @param {CSN.Path} path
   */
  function handleAssociationElement(query, elements, columnMap, publishedMixins, elem, elemName, path) {
    if (isUnion(path) && options.transformation === 'hdbcds') {
      if (isBetaEnabled(options, 'ignoreAssocPublishingInUnion') && doA2J) {
        if (elem.keys)
          info(null, path, `Managed association "${elemName}", published in a UNION, will be ignored`);
        else
          info(null, path, `Association "${elemName}", published in a UNION, will be ignored`);

        elem._ignore = true;
      }
      else {
        error(null, path, `Association "${elemName}" can't be published in a SAP HANA CDS UNION`);
      }
    }
    else if (path.length > 4 && options.transformation === 'hdbcds') { // path.length > 4 -> is a subquery
      error(null, path, { name: elemName },
            'Association $(NAME) can\'t be published in a subquery');
    }
    else {
    /* Old implementation:
    const isNotMixinByItself = !(elem.value && elem.value.path && elem.value.path.length == 1 && art.query && art.query.mixin && art.query.mixin[elem.value.path[0].id]);
    */
      const isNotMixinByItself = checkIsNotMixinByItself(query, columnMap, elemName);
      const { mixinElement, mixinName } = getMixinAssocOfQueryIfPublished(query, elem, elemName);
      if (isNotMixinByItself || mixinElement !== undefined) {
      // If the mixin is only published and not used, only display the __ clone. Kill the "original".
        if (mixinElement !== undefined && !usesMixinAssociation(query, elem, elemName))
          delete query.SELECT.mixin[mixinName];


        // Create an unused alias name for the MIXIN - use 3 _ to avoid collision with usings
        let mixinElemName = `___${mixinName || elemName}`;
        while (elements[mixinElemName])
          mixinElemName = `_${mixinElemName}`;

        // Copy the association element to the MIXIN clause under its alias name
        // (shallow copy is sufficient, just fix name and value)
        const mixinElem = Object.assign({}, elem);
        // Perform common transformations on the newly generated MIXIN element (won't be reached otherwise)
        transformCommon(mixinElem, mixinElemName);

        if (query.SELECT && !query.SELECT.mixin)
          query.SELECT.mixin = Object.create(null);

        // Clone 'on'-condition, pre-pending '$projection' to paths where appropriate,
        // and fixing the association alias just created

        if (mixinElem.on) {
          mixinElem.on = cloneWithTransformations(mixinElem.on, {
            ref: (ref) => {
            // Clone the path, without any transformations
              const clonedPath = cloneWithTransformations(ref, {});
              // Prepend '$projection' to the path, unless the first path step is the (mixin) element itself or starts with '$')
              if (clonedPath[0] === elemName) {
                clonedPath[0] = mixinElemName;
              }
              else if (!(clonedPath[0] && clonedPath[0].startsWith('$'))) {
                const projectionId = '$projection';
                clonedPath.unshift(projectionId);
              }
              return clonedPath;
            },
            func: (func) => {
            // Unfortunately, function names are disguised as paths, so we would prepend a '$projection'
            // above (no way to distinguish that in the callback for 'path' above). We can only pluck it
            // off again here ... sigh
              if (func.ref && func.ref[0] && func.ref[0] === '$projection')
                func.ref = func.ref.slice(1);

              return func;
            },
          });
        }

        if (!mixinElem._ignore)
          columnMap[elemName] = { ref: [ mixinElemName ], as: elemName };

        if (query.SELECT) {
          query.SELECT.mixin[mixinElemName] = mixinElem;

          publishedMixins.set(mixinElem, true);
        }
      }
    }
  }

  /**
   * If following an association, explicitly set the implicit alias
   * due to an issue with HANA - only for hdbcds-hdbcds, I assume flattening
   * takes care of this for the other cases already
   *
   * @param {CSN.Query} query
   * @param {CSN.Path} path
   */
  function addImplicitAliasWithAssoc(query, path) {
    for (let i = 0; i < query.SELECT.columns.length; i++) {
      const col = query.SELECT.columns[i];
      if (!col.as && col.ref && col.ref.length > 1) {
        const { links } = inspectRef(path.concat([ 'columns', i ]));
        if (links && links.slice(0, -1).some(({ art }) => isAssocOrComposition(art && art.type || '')))
          col.as = getLastRefStepString(col.ref);
      }
    }
  }

  /**
   * @param {CSN.Query} query
   * @param {CSN.Artifact} artifact
   * @param {string} artName
   * @param {CSN.Path} path
   */
  // eslint-disable-next-line complexity
  function transformViewOrEntity(query, artifact, artName, path) {
    const { elements } = queryOrMain(query, artifact);
    let hasNonAssocElements = false;
    const isSelect = query && query.SELECT;
    const isProjection = !!artifact.projection || query && query.SELECT && !query.SELECT.columns;
    const columnMap = getColumnMap(query);
    const isSelectStar = query && query.SELECT && query.SELECT.columns && query.SELECT.columns.indexOf('*') !== -1;

    // check all queries/subqueries for mixin publishing inside of unions -> forbidden in hdbcds
    if (query && options.transformation === 'hdbcds' && query.SELECT && query.SELECT.mixin && path.indexOf('SET') !== -1)
      checkForMixinPublishing(query, elements, path);

    // Second walk through the entity elements: Deal with associations (might also result in new elements)
    // Will be initialized JIT inside the elements-loop
    let $combined;

    const publishedMixins = new WeakMap();

    for (const elemName in elements) {
      const elem = elements[elemName];
      if (isSelect) {
        if (!columnMap[elemName])
          addProjectionOrStarElement(query, isProjection, isSelectStar, $combined, columnMap, elemName);

        // For associations - make sure that the foreign keys have the same "style"
        // If A.assoc => A.assoc_id, else if assoc => assoc_id or assoc as Assoc => Assoc_id
        if (elem.keys && doA2J)
          addForeignKeysToColumns(columnMap, elem, elemName);
      }
      // Views must have at least one element that is not an unmanaged assoc
      if (!elem.on && !elem._ignore)
        hasNonAssocElements = true;

      // (180 b) Create MIXINs for association elements in projections or views (those that are not mixins by themselves)
      // CDXCORE-585: Allow mixin associations to be used and published in parallel
      if (query !== undefined && elem.target)
        handleAssociationElement(query, elements, columnMap, publishedMixins, elem, elemName, path);
    }

    if (query && !hasNonAssocElements) {
    // Complain if there are no elements other than unmanaged associations
    // Allow with plain
      error(null, [ 'definitions', artName ], { $reviewed: true },
            'Expecting view or projection to have at least one element that is not an unmanaged association');
    }

    if (isSelect) {
      // Build new columns from the column map - bring elements and columns back in sync basically
      query.SELECT.columns = Object.keys(elements).filter(elem => !elements[elem]._ignore).map(key => stripLeadingSelf(columnMap[key]));
      // If following an association, explicitly set the implicit alias
      // due to an issue with HANA - this seems to only have an effect on ref files with hdbcds-hdbcds, so only run then
      if (options.transformation === 'hdbcds' && options.sqlMapping === 'hdbcds')
        addImplicitAliasWithAssoc(query, path);

      delete query.SELECT.excluding;  // just to make the output of the new transformer the same as the old

      // A2J turned usages into JOINs, we must now remove all non-published mixins (i.e. only keep the clones)
      if (query.SELECT.mixin && doA2J) {
        for (const [ name, mixin ] of Object.entries(query.SELECT.mixin)) {
          if (!publishedMixins.has(mixin))
            delete query.SELECT.mixin[name];
        }
      }
    }
  }
}

/**
 * Walk the given path and check if we are in a UNION.
 * This will return true when it is called on the subquery inside of a SET.args property.
 *
 * @param {CSN.Path} path
 * @returns {boolean}
 */
function isUnion(path) {
  const subquery = path[path.length - 1];
  const queryIndex = path[path.length - 2];
  const args = path[path.length - 3];
  const unionOperator = path[path.length - 4];
  return path.length > 3 && (subquery === 'SET' || subquery === 'SELECT') && typeof queryIndex === 'number' && queryIndex >= 0 && args === 'args' && unionOperator === 'SET';
}

/**
 * Strip of leading $self of the ref
 *
 * @param {object} col A column
 * @returns {object}
 */
function stripLeadingSelf(col) {
  if (col.ref && col.ref.length > 1 && col.ref[0] === '$self')
    col.ref = col.ref.slice(1);

  return col;
}

/**
 * Check that the given element is not a simple mixin-publishing
 *
 * @param {CSN.Query} query
 * @param {object} columnMap
 * @param {string} elementName
 * @returns {boolean}
 */
function checkIsNotMixinByItself(query, columnMap, elementName) {
  if (query && query.SELECT && query.SELECT.mixin) {
    const col = columnMap[elementName];

    // Use getLastRefStepString - with hdbcds.hdbcds and malicious CSN input we might have .id
    const realName = getLastRefStepString(col.ref);
    // If the element is not part of the mixin => True
    return query.SELECT.mixin[realName] === undefined;
  }
  // the artifact does not define any mixins, the element cannot be a mixin
  return true;
}

/**
 * Return the string value of the last ref step - so either the .id or the last step.
 *
 * We cannot use implicitAs, as this causes problems for structured things with hdi-hdbcds naming
 *
 * @param {Array} ref
 * @returns {string}
 */
function getLastRefStepString(ref) {
  const last = ref[ref.length - 1];
  if (last.id)
    return last.id;
  return last;
}

module.exports = {
  getViewTransformer,
};
