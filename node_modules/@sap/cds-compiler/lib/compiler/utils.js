// Simple compiler utility functions

// This file contains small utility functions which do not access the complete
// XSN or functions instantiated using the XSN.

// Please do not add functions “for completeness”, this is not an API file for
// others but only by the core compiler.

'use strict';

const { dictAdd, pushToDict } = require('../base/dictionaries');
const { kindProperties } = require('./base');

// for links, i.e., properties starting with an underscore '_':

function pushLink( obj, prop, value ) {
  const p = obj[prop];
  if (p)
    p.push( value );
  else
    Object.defineProperty( obj, prop, { value: [ value ], configurable: true, writable: true } );
}

// for annotations:

function annotationVal( anno ) {
  return anno && (anno.val === undefined || anno.val); // XSN TODO: set val for anno short form
}
function annotationIsFalse( anno ) {                   // falsy, but not null (unset)
  return anno && (anno.val === false || anno.val === 0 || anno.val === '');
}

function annotateWith( art, anno, location = art.location, val = true, literal = 'boolean' ) {
  if (art[anno])  // do not overwrite user-defined including null
    return;
  art[anno] = {
    name: { path: [ { id: anno.slice(1), location } ], location },
    val,
    literal,
    location,
  };
}

// TODO: define setLink() like the current setProp(), we might have setArtifactLink()
// Do not share this function with CSN processors!

// The link (_artifact,_effectiveType,...) usually has the artifact as value.
// Falsy values are:
// - undefined: not computed yet, parse error, no ref
// - null: no valid reference, param:true if that is not allowed
// - false (only complete ref): multiple definitions, rejected
// - 0 (for _effectiveType only): circular reference
function setLink( obj, value = null, prop = '_artifact' ) {
  Object.defineProperty( obj, prop, { value, configurable: true, writable: true } );
  return value;
}

/**
 * Like `obj.prop = value`, but not contained in JSON / CSN
 * It's important to set enumerable explicitly to false (although 'false' is the default),
 * as else, if the property already exists, it keeps the old setting for enumerable.
 *
 * @param {object} obj
 * @param {string} prop
 * @param {any} value
 */
function setProp(obj, prop, value) {
  const descriptor = {
    value,
    configurable: true,
    writable: true,
    enumerable: false,
  };
  Object.defineProperty( obj, prop, descriptor );
  return value;
}

function linkToOrigin( origin, name, parent, prop, location, silentDep ) {
  const elem = {
    name: { location: location || origin.name.location, id: name },
    kind: origin.kind,
    location: location || origin.location,
  };
  if (origin.name.$inferred)
    elem.name.$inferred = origin.name.$inferred;
  if (parent)
    setMemberParent( elem, name, parent, prop ); // TODO: redef in template
  setProp( elem, '_origin', origin );
  // TODO: should we use silent dependencies also for other things, like
  // included elements?  (Currently for $inferred: 'expand-element' only)
  if (silentDep)
    dependsOnSilent( elem, origin );
  else
    dependsOn( elem, origin, location );
  return elem;
}

function setMemberParent( elem, name, parent, prop ) {
  if (prop) {              // extension or structure include
    // TODO: consider nested ARRAY OF and RETURNS, COMPOSITION OF type
    const p = parent.items || parent.targetAspect || parent;
    if (!(prop in p))
      p[prop] = Object.create(null);
    dictAdd( p[prop], name, elem );
  }
  if (parent._outer)
    parent = parent._outer;
  setProp( elem, '_parent', parent );
  setProp( elem, '_main', parent._main || parent );
  elem.name.absolute = elem._main.name.absolute;
  if (name == null)
    return;
  const normalized = kindProperties[elem.kind].normalized || elem.kind;
  [ 'element', 'alias', 'select', 'param', 'action' ].forEach( ( kind ) => {
    if (normalized === kind)
      elem.name[kind] = (parent.name[kind] != null && kind !== 'select' && kind !== 'alias') ? `${ parent.name[kind] }.${ name }` : name;

    else if (parent.name[kind] != null)
      elem.name[kind] = parent.name[kind];

    else
      delete elem.name[kind];
  });
  // try { throw new Error('Foo') } catch (e) { elem.name.stack = e; };
}

/**
 * Adds a dependency user -> art with the given location.
 *
 * @param {XSN.Artifact} user
 * @param {XSN.Artifact} art
 * @param {XSN.Location} location
 */
function dependsOn( user, art, location ) {
  if (!user._deps)
    setProp( user, '_deps', [] );
  user._deps.push( { art, location } );
}

/**
 * Same as "dependsOn" but the dependency from user -> art is silent,
 * i.e. not reported to the user.
 *
 * @param {XSN.Artifact} user
 * @param {XSN.Artifact} art
 */
function dependsOnSilent( user, art ) {
  if (!user._deps)
    setProp( user, '_deps', [] );
  user._deps.push( { art } );
}

function storeExtension( elem, name, prop, parent, block ) {
  if (prop === 'enum')
    prop = 'elements';
  setProp( elem, '_block', block );
  const kind = `_${ elem.kind }`; // _extend or _annotate
  if (!parent[kind])
    setProp( parent, kind, {} );
  // if (name === '' && prop === 'params') {
  //   pushToDict( parent[kind], 'returns', elem ); // not really a dict
  //   return;
  // }
  if (!parent[kind][prop])
    parent[kind][prop] = Object.create(null);
  pushToDict( parent[kind][prop], name, elem );
}

/** @type {(a: any, b: any) => boolean} */
const testFunctionPlaceholder = () => true;

// Return path step if the path navigates along an association whose final type
// satisfies function `test`; "navigates along" = last path item not considered
// without truthy optional argument `alsoTestLast`.
function withAssociation( ref, test = testFunctionPlaceholder, alsoTestLast = false ) {
  for (const item of ref.path || []) {
    const art = item && item._artifact; // item can be null with parse error
    if (art && art._effectiveType && art._effectiveType.target && test( art._effectiveType, item ))
      return (alsoTestLast || item !== ref.path[ref.path.length - 1]) && item;
  }
  return false;
}

/**
 * Generates an XSN path out of the given name. Path segments are delimited by a dot.
 * Each segment will have the given location assigned.
 *
 * @param {CSN.Location} location
 * @param {string} name
 * @returns {XSN.Path}
 */
function splitIntoPath( location, name ) {
  return name.split('.').map( id => ({ id, location }) );
}

/**
 * @param {CSN.Location} location
 * @param  {...any} args
 */
function augmentPath( location, ...args ) {
  return { path: args.map( id => ({ id, location }) ), location };
}


module.exports = {
  pushLink,
  annotationVal,
  annotationIsFalse,
  annotateWith,
  setLink,
  setProp,
  linkToOrigin,
  dependsOn,
  dependsOnSilent,
  setMemberParent,
  storeExtension,
  withAssociation,
  augmentPath,
  splitIntoPath,
};
